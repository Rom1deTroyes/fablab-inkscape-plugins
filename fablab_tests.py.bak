#!/usr/bin/env python
# encoding: utf-8

import sys
import copy
import math

sys.path.append('/usr/share/inkscape/extensions')
import inkex
import simplepath
import simpletransform
import simplestyle

from pathmodifier import  PathModifier


def print_(*arg):
    f = open("fablab_debug.log", "a")
    for s in arg:
        s = str(unicode(s).encode('unicode_escape')) + " "
        f.write(s)
    f.write("\n")
    f.close()


def unsignedLong(signedLongString):
    longColor = long(signedLongString)
    if longColor < 0:
        longColor = longColor & 0xFFFFFFFF
    return longColor


def getColorString(longColor):
    longColor = unsignedLong(longColor)
    hexColor = hex(longColor)[2:-3]
    hexColor = hexColor.rjust(6, '0')
    return '#' + hexColor.upper()


TROTEC_COLORS = [
    '#ff0000',
    '#0000ff',
    '#336699',
    '#00ffff',
    '#00ff00',
    '#009933',
    '#006633',
    '#999933',
    '#996633',
    '#663300',
    '#660066',
    '#9900cc',
    '#ff00ff',
    '#ff6600',
    '#ffff00'
]


# precision to 1/100 px should be sufficient for designs in mm ?
PRECISION = 100.0


def roundValues(arr):
    return [roundValue(val) for val in arr]


def roundValue(val):
    return round(val, PRECISION)


def similar(a, b):
    print_(a, b)
    if type(a) is list and type(b) is list:
        return False not in[similar(c[0], c[1]) for c in zip(a, b)]
    else:
        return abs(roundValue(a) - roundValue(b)) <= 2 / PRECISION


def node_color(node):
    return simplestyle.parseStyle(node.get('style','')).get('stroke', None)


class Polyline:

    def __init__(self, initial_segment=None):
        self.segments = [initial_segment]

    def start_point(self):
        return self.segments[0].start

    def end_point(self):
        return self.segments[-1].end

    def append(self, segment):
        if(segment.start == self.end_point()):
            self.segments.append(segment)
        else:
            raise AssertionError("can't add segment that does not start with end_point of the current Polyline")

    def length(self):
        return len(self.segments)

    def to_simplepath(self):
        path = []
        if self.length() > 0:
            path.append(self.segments[0].simplePathStart())
            path.extend((p.simplePathEnd() for p in self.segments))
        return path

    def format(self):
        return simplepath.formatPath(self.to_simplepath())

    def reverse(self):
        self.segments.reverse()
        for segment in self.segments:
            segment.reverse()

    def _contruct_from_segment_array(self, arr):
        while True:
            next_segment = Segment.find_and_flag_next_segment(self.end_point(), arr)
            if(next_segment is not None):
                self.append(next_segment)
            else:
                break

    def distance_to(self, polyline):
        x1, y1 = self.end_point()
        x2, y2 = polyline.start_point()
        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)

    def distance_to_reversed(self, polyline):
        x1, y1 = self.end_point()
        x2, y2 = polyline.end_point()
        return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)

    @classmethod
    def generate_from_segment_array(cls, arr):
        ''' Generate (yield) polylines(array of consecutive segments) from the specified segment array.
            Before running, segments in the array must not be flaged 'used'.
        '''
        for segment in arr:
            if(not segment.used):
                segment.used = True
                polyline = Polyline(segment)
                polyline._contruct_from_segment_array(arr)
                polyline.reverse()
                polyline._contruct_from_segment_array(arr)
                yield polyline

    @classmethod
    def optimize_order(cls, arr):
        last_poly = Origin()
        while len(arr) > 0:
            next_poly = None
            dist = None
            for polyline in arr:
                if(next_poly is None):
                    next_poly = polyline
                    dist = last_poly.distance_to(polyline)

                if(last_poly.distance_to(polyline) < dist):
                    next_poly = polyline
                    dist = last_poly.distance_to(polyline)

                if(last_poly.distance_to_reversed(polyline) < dist):
                    polyline.reverse()
                    next_poly = polyline
                    dist = last_poly.distance_to(polyline)

            last_poly = next_poly
            arr.remove(next_poly)
            yield next_poly


class Origin(Polyline):

    def __init__(self):
        pass

    def start_point(self):
        return [0, 0]

    def end_point(self):
        return [0, 0]

    def append(self, segment):
        raise AssertionError("can't add segment to Origin")

    def length(self):
        return 0

    def to_simplepath(self):
        raise AssertionError("can't convert to Origin to simplemath")

    def format(self):
        raise AssertionError("can't convert to Origin to simplemath")

    def reverse(self):
        pass

    def _contruct_from_segment_array(self, arr):
        raise AssertionError("can't add segment to Origin")


class Segment:
    def __init__(self, start, end, command='L', extra_parameters=[]):
        self.start = roundValues(start)
        self.end = roundValues(end)
        self.command = command
        self.extra_parameters = roundValues(extra_parameters)
        self.used = False

    def simplePathStart(self):
        return ['M', self.start]

    def simplePathEnd(self):
        parameters = self.extra_parameters[:]
        parameters.extend(self.end)
        return [self.command, parameters]

    def toSimplePath(self):
        return [self.simplePathStart(), self.simplePathEnd()]

    def formatPath(self):
        return simplepath.formatPath(self.toSimplePath())

    def is_similar_to_segment(self, other):
        return similar(self.start, other.start) and similar(self.end, other.end) and self.command == other.command and similar(self.extra_parameters, other.extra_parameters)

    def __eq__(self, other):
        if(isinstance(other, Segment)):
            if self.is_similar_to_segment(other):
                return True
            inv = copy.deepcopy(self)
            inv.reverse()
            return inv.is_similar_to_segment(other)
        else:
            raise NotImplemented()

    def __hash__(self):
        h = self.command.__hash__()
        for c in self.start:
            h += c.__hash__()
        for c in self.end:
            h += c.__hash__()
        for c in self.extra_parameters:
            h += c.__hash__()
        return h

    def reverse(self):
        if self.command == 'L':
            self.end, self.start = self.start, self.end
        elif self.command == 'C':
            self.end, self.start = self.start, self.end
            self.extra_parameters[:2], self.extra_parameters[2:4] = self.extra_parameters[2:4], self.extra_parameters[:2]
        else:
            inkex.errormsg("Path Command %s can't be reversed Yet" % self.command)

    @classmethod
    def convertToSegments(cls, path):
        path_start = None
        currentPoint = None

        for cmd, params in simplepath.parsePath(path.get('d')):
            if(cmd == 'M'):
                if(path_start is None):
                    path_start = params
                currentPoint = params

            elif(cmd == 'L'):
                yield Segment(currentPoint, params)
                currentPoint = params

            elif (cmd == 'C'):
                yield Segment(currentPoint, params[-2:], command='C', extra_parameters=params[:-2])
                currentPoint = params[-2:]

            elif (cmd == 'Z'):
                # Z is a line between the last point and the start of the shape
                yield Segment(currentPoint, path_start)
                currentPoint = None
                path_start = None

            else:
                inkex.errormsg("Path Command %s not managed Yet" % cmd)

    @classmethod
    def find_and_flag_next_segment(cls, end, arr):
        '''
            Find a segment that can be placed after the 'end' point in the polyline. Can reverse a segment if needed.
            Mark the segment used (Segement.used = True) before returning it.
             - end : last point of the polyline
             - arr : array of segments
        '''
        for segment in arr:
            if not segment.used:
                if segment.end == end:
                    segment.reverse()

                if segment.start == end:
                    segment.used = True
                    return segment

        return None

# TODO
# Correct bugs on clone stranslation, in some case resutant transform matrix are wrong
# Mange all type of path for reversion (Segment)
# Try to convert to path simple elements such as line, rectangle, ...
class MyEffect(inkex.Effect):
    def __init__(self):
        """
        Constructor.
        Defines the "--what" option of a script.
        """
        # Call the base class constructor.
        inkex.Effect.__init__(self)
        self.OptionParser.add_option('--tab')
        self.start_stop = {}

    def extract_optimizable_paths_by_color(self, nodes, with_transform_matrix = None):
        '''
            nodes must be an iterator on svg node objects (array, generator,group node, ...). 
            Will generate tuples (color,path) where color is either a valid TROTEC color, 
            'engrave' for element that are used for engraving or 'unsupported' for element(nodes) that
            are note supported. Notice that text nodes are supported for engraving but not for cut optimization.
        '''
        print_(nodes)
        for node in nodes:

            # merge transformation for this node and all parents
            print_("clone transform matrix", with_transform_matrix)
            transform_matrix = simpletransform.composeParents(node, [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0]])
            print_("matrix before", transform_matrix)
            if(with_transform_matrix):
                transform_matrix = simpletransform.composeTransform(with_transform_matrix, transform_matrix)
            print_("matrix after", transform_matrix)

            # work on copy to be sure not breaking anything
            node_copy = copy.deepcopy(node)
            node_copy.set("transform", simpletransform.formatTransform(transform_matrix))

            # Path Nodes
            if node.tag == "{http://www.w3.org/2000/svg}path":
                # apply transformation info on path, otherwise dealing with transform would be a mess
                simpletransform.fuseTransform(node_copy)

                # get style, check color, ...
                color = node_color(node_copy)

                if(color in TROTEC_COLORS):
                    yield color, node_copy
                else:
                    yield 'engrave', node_copy

            # Clone nodes
            elif node.tag == "{http://www.w3.org/2000/svg}use":
                inkex.errormsg(u"Aïe un clone, ca risque de ne pas marcher, ou peut être que si, ou pas.")
                # yield 'unsupported', 'clone'
                cloned_id = node.get('{http://www.w3.org/1999/xlink}href', '#')[1:]
                cloned = self.getElementById(cloned_id)

                if(cloned is None):
                    raise AssertionError("Element %s not found when resolving clone" % cloned_id)
                else:
                    clone_matrix = simpletransform.composeParents(node, [[1.0, 0.0, float(node.get('x', 0.0))], [0.0, 1.0, float(node.get('y', 0.0))]])
                    if(with_transform_matrix):
                        clone_matrix = simpletransform.composeTransform(with_transform_matrix, transform_matrix)
                    for color, path in self.extract_optimizable_paths_by_color([cloned], clone_matrix):
                        yield color, path
                pass

            # pour virer les groupes et les clones regarder pathmodifier.py y'a plein de choses interessantes

            # Rectangle nodes
            elif node.tag == "{http://www.w3.org/2000/svg}rect":
                yield 'unsupported', 'rectangle'
                pass

            # Circle nodes
            elif node.tag == "{http://www.w3.org/2000/svg}circle":
                yield 'unsupported', 'cercle'
                pass

            # Ellipse nodes
            elif node.tag == "{http://www.w3.org/2000/svg}ellispe":
                yield 'unsupported', 'ellispe'
                pass

            # Line nodes
            elif node.tag == "{http://www.w3.org/2000/svg}line":
                yield 'unsupported', 'ligne'
                pass

            # Line nodes
            elif node.tag == "{http://www.w3.org/2000/svg}polyline":
                yield 'unsupported', 'polyligne'
                pass

            # Line nodes
            elif node.tag == "{http://www.w3.org/2000/svg}polygone":
                yield 'unsupported', 'polygone'
                pass

            # Text nodes
            elif node.tag == "{http://www.w3.org/2000/svg}text":
                if(node_color(node) in TROTEC_COLORS):
                    yield 'unsupported', 'texte'
                else:
                    yield 'engrave', node_copy
                pass

            # Group nodes
            elif node.tag == "{http://www.w3.org/2000/svg}g":
                for color, path in self.extract_optimizable_paths_by_color(node, with_transform_matrix):
                    yield color, path
                pass

            # Image nodes
            elif node.tag == "{http://www.w3.org/2000/svg}image":
                yield 'engrave', node_copy

            else:
                yield 'unsupported', node.tag
                pass

    def effect(self):
        if len(self.selected) == 0:
            inkex.errormsg(u"Merci de selectionner les éléments à optimiser pour la découpe laser.")
            return

        parent = self.current_layer

        # Create a group where we wil write nodes. Determine BoundingBox to mode the  output near the original selection
        # x1, y1, x2, y2 = simpletransform.computeBBox(self.selected.values())
        grp = inkex.etree.SubElement(parent, inkex.addNS('g', 'svg'), {'transform': "translate(%s,%s)" % (200, 200)})

        segments_by_color = {}

        for color, path in self.extract_optimizable_paths_by_color((self.selected.get(n) for n in self.selected)):
            if color not in segments_by_color:
                segments_by_color[color] = set()

            if color in TROTEC_COLORS:
                segments_by_color[color].update(Segment.convertToSegments(path))
            else:
                segments_by_color[color].add(path)

        # Check for unsupported elments
        if('unsupported' in segments_by_color):
            inkex.errormsg(u"Les elements de type %s ne sont pas supportés. Merci de les convertir en Chemin (Chemin>>Objets en chemins) et de de-lier les clones." % ", ".join(segments_by_color.get('unsupported')))
            return

        # Add a copy of elements for engraving
        grp.extend(segments_by_color.get('engrave', []))

        # Add optimized path for lasercut
        for color in TROTEC_COLORS:
            for poly in Polyline.optimize_order([p for p in Polyline.generate_from_segment_array(segments_by_color.get(color, []))]):
                line_attribs = {'style': "fill:none;stroke:%s;stroke-width:2;marker-end:url(#Arrow2Mend)" % color, 'd': poly.format()}
                inkex.etree.SubElement(grp, inkex.addNS('path', 'svg'), line_attribs)


if __name__ == '__main__':
    effect = MyEffect()
    effect.affect()
